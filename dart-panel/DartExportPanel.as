/*** Copyright (c) 2013, Adobe Systems Inc.* All rights reserved.* * Redistribution and use in source and binary forms, with or without modification, are permitted provided * that the following conditions are met:* - Redistributions of source code must retain the above copyright notice, this list of conditions and the *   following disclaimer.* - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and *   the following disclaimer in the documentation and/or other materials provided with the distribution.* - Neither the name of Adobe Systems Inc. nor the names of its contributors may be used to endorse or *   promote products derived from this software without specific prior written permission.* * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/package {		import com.gskinner.easelexport.PanelEvent;	import com.gskinner.easelexport.panels.BaseSlidingPanel;	import com.gskinner.easelexport.panels.SettingsPanel;	import com.gskinner.easelexport.panels.TimelinePanel;	import com.gskinner.easelexport.panels.TopPanel;		import fl.controls.CheckBox;	import fl.controls.ScrollBar;	import fl.events.ScrollEvent;	import fl.managers.StyleManager;		import flash.display.Graphics;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.external.ExternalInterface;	import flash.net.SharedObject;	import flash.text.AntiAliasType;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.net.URLRequest;	import flash.net.navigateToURL;	import fl.controls.CheckBox;		import adobe.utils.MMExecute;	import flash.system.Capabilities;	import flash.events.UncaughtErrorEvent;	import flash.events.ErrorEvent;	import flash.display.MovieClip;	import flash.geom.ColorTransform;	import com.gskinner.controls.CS7TextInput;		public class DartExportPanel extends Sprite {				protected static var MOUSE_SCROLL_SPEED:Number = 4;		protected static const MIN_WIDTH:uint=275;		protected static const MIN_HEIGHT:uint=100;		public static const SCROLLBAR_WIDTH:int = 13;				protected var currentDocumentID:String;		protected var frameCount:int=0;		protected var _enabled:Boolean;		protected var panelStack:Vector.<BaseSlidingPanel>;				protected var topMenu:TopPanel;		protected var timelinePanel:TimelinePanel;		protected var settingsPanel:SettingsPanel;						protected var scrollbar:ScrollBar;		protected var content:Sprite;		protected var contentHeight:int;		protected var viewHeight:int;		protected var viewWidth:int;				public var bg:Sprite;		public var macText:TextField;		public var macTextBold:TextField;		public var windowsText:TextField;				protected var settings:Object;		protected var defaultSettings:Object;				protected var fontManager:FontManager;				protected var running:Boolean=false;				public var errorFld:TextField;				public function DartExportPanel() {			visible = false;						//loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, uncaughtErrorHandler);						StyleManager.setStyle("scrollBarWidth", SCROLLBAR_WIDTH);			StyleManager.setStyle('focusRectPadding', 1);			while (numChildren){ removeChildAt(0); }						stage.scaleMode = StageScaleMode.NO_SCALE;			stage.align = StageAlign.TOP_LEFT;									//Support mouse wheel			addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel, false, 0, true);						// load default settings:			defaultSettings = settings = JSFL.deserialize(JSFL.call("getDefaultSettings"));						//Load locale first...			Locale.onComplete = init;			Locale.load(JSFL.isDebug ? "strings.xml" : JSFL.call("getLocaleURI"));		}				public function init():void {			tabChildren = false;						FontManager.init(macText.defaultTextFormat.font, macTextBold.defaultTextFormat.font, windowsText.defaultTextFormat.font, windowsText.defaultTextFormat.font);						configUI();						stage.addEventListener(Event.RESIZE, onStageResized, false, 0, true);						if (!JSFL.isDebug){				ExternalInterface.addCallback("onDocumentChanged", onDocumentChanged);				ExternalInterface.addCallback("onDocumentSaved", onDocumentSaved);				ExternalInterface.addCallback("onTimelineChanged", onTimelineChanged);				ExternalInterface.addCallback("onThemeChanged", onThemeChanged);				ExternalInterface.addCallback("export", runExport);				ExternalInterface.addCallback("isOpen", isOpen);				JSFL.call("registerEventListeners","Toolkit for Dart");				checkDocument();				loadTimelineProps();			}									stage.addEventListener(Event.ENTER_FRAME, handleRender);									updateTheme();		}				protected function handleRender(evt:Event):void {			// solves issues with components taking until render to show up correctly.			stage.removeEventListener(Event.ENTER_FRAME, handleRender);			visible = true;			onStageResized(null);		}						protected function configUI():void {						content = new Sprite();			addChild(content);						topMenu = new TopPanel();			topMenu.addEventListener(PanelEvent.SETTING_CHANGED, onSettingsChanged, false, 0, true);			topMenu.addEventListener(PanelEvent.EXPORT_CLICKED, onExportClicked, false, 0, true);			topMenu.addEventListener(PanelEvent.HELP_CLICKED, onHelpClicked, false, 0, true);			topMenu.versionText.text = (JSFL.isDebug ? "DEBUG" : "v"+JSFL.call("getPanelVersion"));			addChild(topMenu);						timelinePanel = new TimelinePanel();			timelinePanel.addEventListener(PanelEvent.OPENING, onPanelAnimation, false, 0, true);			timelinePanel.addEventListener(PanelEvent.CLOSING, onPanelAnimation, false, 0, true);			timelinePanel.addEventListener(PanelEvent.SETTING_CHANGED, onTimelineSettingsChanged, false, 0, true);						settingsPanel = new SettingsPanel();			settingsPanel.addEventListener(PanelEvent.OPENING, onPanelAnimation, false, 0, true);			settingsPanel.addEventListener(PanelEvent.CLOSING, onPanelAnimation, false, 0, true);			settingsPanel.addEventListener(PanelEvent.SETTING_CHANGED, onSettingsChanged, false, 0, true);			settingsPanel.addEventListener(PanelEvent.EDIT_CLICKED, onEditClicked, false, 0, true);			settingsPanel.addEventListener(PanelEvent.OUTPUT_CLICKED, onOutputClicked, false, 0, true);						//Add panels panelStack to be stacked vertically			panelStack = new <BaseSlidingPanel>[timelinePanel, settingsPanel];			for(var i:int = 0, l:int = panelStack.length; i < l; i++){ 				content.addChild(panelStack[i]); 			}						//Scrollbar			scrollbar = new ScrollBar();			scrollbar.scrollPosition = 0;			scrollbar.minScrollPosition = 0;			scrollbar.addEventListener(ScrollEvent.SCROLL, onScroll, false, 0, true);			addChild(scrollbar);						bg = new PanelBg();			addChildAt(bg, 0);		}				protected function onStageResized(event:Event):void {			viewWidth = Math.max(MIN_WIDTH,stage.stageWidth);			viewHeight = Math.max(MIN_HEIGHT,stage.stageHeight);			updateLayout();		}				protected function onScroll(event:ScrollEvent):void {			content.y = -scrollbar.scrollPosition;		}				protected function onMouseWheel(event:MouseEvent):void {			if(!scrollbar.visible || !enabled){ return; }			scrollbar.scrollPosition -= event.delta * MOUSE_SCROLL_SPEED;			content.y = -scrollbar.scrollPosition;		}				protected function onEditClicked(evt:Event):void {			var str:String = JSFL.call("openSettingsDialog", JSFL.serialize(settings));			if (!str) { return; }			var data = JSFL.deserialize(str);			mergeSettings(data, settings, true);			updateDisplayOutputPath();			saveSettings();		}				protected function onOutputClicked(evt:Event):void {			JSFL.call("openOutputPath");		}						protected function updateDisplayOutputPath():void {			settingsPanel.displayOutputPath = JSFL.call("getDisplayPath",settings.outputPath)||"";		}				protected function mergeSettings(source:Object, target:Object, overwrite:Boolean=false):void {			for (var n:String in source) {				if (overwrite || target[n] === undefined) { target[n] = source[n]; }			}		}						protected function onHelpClicked(event:Event):void {			navigateToURL(new URLRequest(Locale.get("EJS_UI_HELPURL")));		}				protected function onExportClicked(event:Event):void {			runExport();		}				protected function onSettingsChanged(event:Event):void {			saveSettings();		}				protected function onTimelineSettingsChanged(event:Event):void {			saveTimelineSettings();		}				//A panel has opened or closed, save the settings and add the animation listener.		protected function onPanelAnimation(event:Event):void {			addEventListener(Event.ENTER_FRAME, onEnterFrame, false, 0, true);		}				//While any of the frames are animating, update view each frame.		protected function onEnterFrame(event:Event):void {			//Update y position of all panels			var isAnimating:Boolean = updatePanelLayout();			//Update scrollbar			updateScrollBar();			if (scrollbar.visible) {				updateScrollPosition();			}			//Remove enterFrame if we're done			if (!isAnimating) { removeEventListener(Event.ENTER_FRAME, onEnterFrame); }		}				protected function updateLayout():void {			updateScrollBar();			updatePanelLayout();			updateScrollPosition();			topMenu.width = Math.max(MIN_WIDTH, viewWidth);						bg.width = viewWidth;			bg.height = viewHeight;					}				protected function updateScrollBar():void {			var bottom:int = settingsPanel.y + settingsPanel.height - topMenu.height;			if(bottom <= viewHeight - topMenu.height){				scrollbar.visible = false;			} else {				scrollbar.visible = true;				scrollbar.y = topMenu.height;				scrollbar.setSize(20, viewHeight - scrollbar.y);				scrollbar.x = viewWidth - SCROLLBAR_WIDTH;			}		}					protected function updateScrollPosition():void {			scrollbar.maxScrollPosition = Math.max(0, contentHeight - viewHeight + topMenu.height);			if(content.y < -scrollbar.maxScrollPosition && scrollbar.scrollPosition == scrollbar.maxScrollPosition){				content.y = -scrollbar.maxScrollPosition;			}		}				//Update position and size of panels in the panelStack.		//Returns true if any of the panels are still animating.		protected function updatePanelLayout():Boolean {			var isAnimating:Boolean = false;			contentHeight = 0;			for (var i:int = 0, l:int = panelStack.length; i < l; i++){				panelStack[i].y = topMenu.height + contentHeight ;				if (scrollbar.visible) { // Native panels don't do this.					panelStack[i].width = viewWidth - SCROLLBAR_WIDTH;				} else {					panelStack[i].width = viewWidth;				}				if(panelStack[i].isAnimating){ isAnimating = true; }				contentHeight += panelStack[i].height + 1;			}			return isAnimating;		}				protected function updateTheme():void {						ThemeManager.updateTheme();						// update appropriate sprites and styles			var tf:TextFormat = StyleManager.getStyle('textFormat') as TextFormat;			tf.color = ThemeManager.getParam('themeStaticTextNormalColor');			StyleManager.setStyle('textFormat', tf);			//StyleManager.setComponentStyle(CheckBox, 'textFormat', tf);			var ctf:ColorTransform = bg.transform.colorTransform;			ctf.color = ThemeManager.getParam('themeAppBackgroundColor');			bg.transform.colorTransform = ctf;		}					protected function runExport():void {			if (running) { return; }			saveSettings();			if (JSFL.call("canRunExport",settings.outputPath) == "false") { return; }			this.mouseEnabled = false;			topMenu.exportLabel.text = Locale.get("EJS_UI_BUTTON_WAIT");			enabled = false;			running = true; // enabled is used at other times as			frameCount = 2;			addEventListener(Event.ENTER_FRAME,startExport);		}				protected function startExport(evt:Event):void {			if (frameCount-- > 0) { return; }			removeEventListener(Event.ENTER_FRAME,startExport);			var path = JSFL.call("runExport");			//if (path) { navigateToURL(new URLRequest(path)); }						addEventListener(Event.ENTER_FRAME,endExport);		}				protected function endExport(evt:Event):void {			topMenu.exportLabel.text = Locale.get("EJS_UI_BUTTON_EXPORT");			enabled =  true;			running = false;			checkDocument();			removeEventListener(Event.ENTER_FRAME,endExport);		}				protected function get enabled():Boolean { return _enabled; }		protected function set enabled(value:Boolean):void {			_enabled = value;			this.mouseEnabled = _enabled;			topMenu.enabled = _enabled;			timelinePanel.enabled = _enabled;			settingsPanel.enabled = _enabled;			scrollbar.mouseChildren = _enabled;			scrollbar.alpha = _enabled? 1 : .5;		}					protected function saveSettings(evt:Event=null):void {			// settings stored in the panel should be updated here://			settings.preview = topMenu.isPreviewChecked;			settings.outputPath = JSFL.call("getOutputPath",settings.outputPath); // check if the path is relative.			JSFL.call("saveData",JSFL.serialize(settings));		}				protected function saveTimelineSettings(evt:Event=null):void {			var o:Object = {loop:timelinePanel.isLoopChecked.toString()}			JSFL.call("saveTimelineData",JSFL.serialize(o));		}				protected function loadSettings():void {			settings = JSFL.deserialize(JSFL.call("loadData")) || {};			mergeSettings(defaultSettings, settings, false);						// update the panel display:			//topMenu.isPreviewChecked = (settings.preview == "true");			updateDisplayOutputPath();						//JSFL._trace("*** LOAD ***\n"+JSFL.serialize(settings));		}				protected function checkDocument():void {			if (running) { return; }			var id:String = JSFL.call("getDocumentID");			if (id != currentDocumentID) {				loadSettings();				currentDocumentID = id;				enabled = !!currentDocumentID;			}		}				protected function loadTimelineProps() {			if (running) { return; }			var o:Object = JSFL.deserialize(JSFL.call("loadTimelineData")) || {};			timelinePanel.isLoopChecked = (o.loop != "false");		}					// external interface methods:		protected function onDocumentChanged() {				checkDocument();		}				protected function onDocumentSaved() {			var id:String = JSFL.call("getDocumentID");			if (id != currentDocumentID) {				saveSettings(); // in case the output path is now relative.				checkDocument();			}		}				protected function onTimelineChanged():void {			loadTimelineProps();		}				protected function onThemeChanged():void {									updateTheme();		}		protected function isOpen():Boolean {			return true;		}			// event handlers:			protected function uncaughtErrorHandler(event:UncaughtErrorEvent):void {			var message:String;						if (event.error is Error) {				message = Error(event.error).message;				message += "\n\n"+Error(event.error).getStackTrace();			} else if (event.error is ErrorEvent) {				message = ErrorEvent(event.error).text;			} else {				message = event.error.toString();			}			//errorFld.text = message;			//addChild(errorFld);			JSFL._trace('** Uncaught Error: \n\n'+message);		}			}}